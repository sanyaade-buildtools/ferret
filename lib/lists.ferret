-- lists.ferret
--

in Lists use Ext ;

-- create a list from a single item
: list ( x -- xs ) [] swap , ;

-- create a list with an element repeated n times
: rep ( x n -- xs ) let x n -> [n for x next] ;

-- apply a block n times and collect the results
: collect ( xt n -- xs ) let f n -> [n for f apply next] ;

-- generate a list of numbers from [1..n]
: iota ( n -- xs ) let n -> [n for n i - next] ;

-- find the last element of a list
: last ( xs -- x ) uncons swap each drop i next ;

-- true if any item in a list matches a predicate
: any ( xs p -- bool ) let p -> each i p apply if T exit then next F ;

-- true if all items in a list match a predicate
: all ( xs p -- bool ) inverse any not ;

-- return the first element of a list to match a predicate
: find ( xs p -- x T | F ) let p -> each i p apply if i T exit then next F ;

-- return true if any element of a list is x
: elem ( xs x -- bool ) is any ;

-- apply a block for every element in a list
: iter ( xs xt -- j*x ) let xt -> each i xt apply next ;

-- concatenate two lists
: append ( xs xs -- xs ) {,} foldr ;

-- join a list of lists
: concat ( [xs] -- xs ) [] {append} foldl ; 

-- map a block across a list, collect the results
: map ( xs xt -- xs ) let xs f -> [xs each i f apply next] ;

-- delete elements from a list that do not match a predicate
: filter ( xs p -- xs ) let xs p -> [xs each i p apply if i then next] ;

-- remove elements from a list that match a predicate
: remove-if ( xs p -- xs ) inverse filter ;

-- remove all occurances of an element from a list
: remove ( xs x -- xs ) is remove-if ;

-- count how many times a predicate is matched in a list
: count-if ( xs p -- n ) {if 1+ then} compose 0 swap foldl ;

-- count the number of times an element occurs in a list
: count ( xs x -- n ) is count-if ;

-- find the best fit in a list
: select ( xs f -- x ) push uncons pop foldl ;
