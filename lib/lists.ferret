-- lists.ferret
--

in Lists use Ext ;

-- create a list from a single item
: list ( x -- xs ) [] swap , ;

-- create a list with an element repeated n times
: rep ( x n -- xs ) [] swap for over , next nip ;

-- apply a block n times and collect the results
: collect ( xt n -- xs ) [] swap for over apply , next nip ;

-- generate a list of numbers from [1..n]
: iota ( n -- xs ) [] swap for i 1 + , next ;

-- find the last element of a list
: last ( xs -- x ) uncons swap each drop i next ;

-- true if any item in a list matches a predicate
: any ( xs p -- bool ) with p -> each i p apply if T exit then next F ;

-- true if all items in a list match a predicate
: all ( xs p -- bool ) inverse any not ;

-- return the first element of a list to match a predicate
: find ( xs p -- x t | f ) with p -> each i p apply if i T exit then next F ;

-- return true if any element of a list is x
: elem ( xs x -- bool ) is any ;

-- apply a block for every element in a list
: iter ( xs xt -- j*x ) with xt -> each i xt apply next ;

-- concatenate two lists
: append ( xs xs -- xs ) {,} foldr ;

-- join a list of lists
: concat ( [xs] -- xs ) [] {append} foldl ; 

-- map a block across a list, collect the results
: map ( xs xt -- xs ) {,} compose [] swap foldr ;

-- delete elements from a list that do not match a predicate
: filter ( xs p -- xs ) with p -> [] {dup p apply if , else drop then} foldr ;

-- remove elements from a list that match a predicate
: remove-if ( xs p -- xs ) inverse filter ;

-- remove all occurances of an element from a list
: remove ( xs x -- xs ) is remove-if ;

-- count how many times a predicate is matched in a list
: count-if ( xs p -- n ) {if 1 + then} compose 0 swap foldl ;

-- count the number of times an element occurs in a list
: count ( xs x -- n ) is count-if ;

-- find the best fit in a list
: select ( xs f -- x ) push uncons pop foldl ;

-- take elements from a list while a predicate holds true
: take-while ( xs p -- xs ys ) 

-- take the first n elements of a list
: take ( xs n -- xs ys )

-- take the first n items from a list
take: fn [n xs] [
  if (n < 1) `or` (null? xs) [[]] [
    (head xs) , (take n - 1 tail xs)
  ]
]


-- zip the elements of two lists with a function
zip-with: fn [f xs ys] [
  if (null? xs) `or` (null? ys) [[]] [
    (f head xs head ys) , (zip-with :f tail xs tail ys)
  ]
]

-- zip elements of two lists with the pair function
zip: fn [xs ys] [
  zip-with :@ xs ys
]

-- the inverse of zip
unzip: fn [xs] [
  foldr fn [a x] [((fst x) , (fst a)) @ ((snd x) , (snd a))] [] @ [] xs
]

-- combine all the elements of two lists
combine-with: fn [f xs ys] [
  foldr fn [ay y] [foldr fn [ax x] [(f x y) , ax] ay xs] [] ys
]

-- combine elements of two lists with the pair function
combine: fn [xs ys] [
  combine-with :@ xs ys
]

-- take the first n items from a list
take: fn [n xs] [
  if (n < 1) `or` (null? xs) [[]] [
    (head xs) , (take n - 1 tail xs)
  ]
]

-- keep taking elements while a predicate is true
take-while: fn [pred xs] [
  if (not pred head xs) `or` (null? xs) [[]] [
    (head xs) , (take-while :pred tail xs)
  ]
]

-- partition a list at the first place a predicate fails
split-when: fn [pred xs] [
  if (null? xs) `or` (pred head xs) [[] @ xs] [
    let [s: split-when :pred tail xs] [
      ((head xs) , (fst s)) @ (snd s)
    ]
  ]
]

-- split a list at the given index
split-at: fn [n xs] [
  if (null? xs) `or` (n < 1) [[] @ xs] [
    let [s: split-at (n - 1) (tail xs)] [
        ((head xs) , (fst s)) @ (snd s)
    ]
  ]
]

-- remove the nth element from a list
delete-at: fn [n xs] [
  let [s: split-at n xs] [
    if null? snd s [fst s] [append fst s tail snd s]
  ]
]

-- remove the first occurance of a true predicate from a lsit
delete-if: fn [pred xs] [
  let [s: split-when :pred xs] [
    if null? snd s [fst s] [append fst s tail snd s]
  ]
]

-- remove the first occurance of an element from a list
delete: fn [x xs] [
  delete-if (is x) xs
]

-- remove all duplicates from a list
nub: fn [xs] [
  if null? xs [[]] [
    let [x: head xs] [x , nub remove x tail xs]
  ]
]

-- remove elements from xs that occur in ys
difference: fn [xs ys] [
  foldl fn [acc x] [delete x acc] xs ys
]

-- keep elements of xs that occur in ys
intersect: fn [xs ys] [
  filter fn [x] [elem x ys] xs
]

-- create a union set of xs and ys
union: fn [xs ys] [
  nub append xs ys
]

-- return a list of cons counting duplicates
duplicates: fn [xs] [
  if null? xs [[]] [
    ;(let* ((x $ car xs)
    ;       (s $ partition (fn (i) (= i x)) xs))
    ;  (cons (cons x (length (car s))) $ duplicates $ cdr s))))
  ]
]

-- partition a list into two lists by predicate
partition: fn [pred xs] [
  ;(let ((sel (fn (x p)
  ;             (if (pred x)
  ;                 (cons (cons x (car p)) (cdr p))
  ;               (cons (car p) $ cons x $ cdr p)))))
  ;  (foldr (fn (acc x) (sel x acc)) (cons nil nil) xs)))
]

-- merge two (sorted) lists together
merge-with: fn [f xs ys] [
  if null? xs [ys] [
    if null? ys [xs] [
      let [x: head xs y: head ys] [
        if f x y [
          x , merge-with :f tail xs ys
        ] [
          y , merge-with :f xs tail ys
        ]
      ]
    ]
  ]
]

-- merge two lists in ascending order
merge: fn [xs ys] [
  merge-with :< xs ys
]

-- sort a list of elements
;(defn sort-with (f xs)
;  (foldl (fn (acc ys) (merge-with f acc ys)) nil (map list xs)))

-- sort a list in ascending order
;(defn sort (xs)
;  (sort-with < xs))

-- inserts an element into a list sorted
insert-with: fn [f x xs] [
  let [s: split-when fn [i] [f x i] xs] [
    append fst s (x , snd s)
  ]
]

-- iinsert an element into a list in ascending order
insert: fn [x xs] [
  insert-with :< x xs
]

-- randomize the elements of a list
;(defn randomize (xs)
;  (map cdr $ sort $ map (fn (x) (cons (uniform) x)) xs))