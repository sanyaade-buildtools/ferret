-- lists.ferret
--

in Lists use Ext ;

-- create a list from a single item
: list ( x -- xs ) [] swap , ;

-- create a list with an element repeated n times
: rep ( x n -- xs ) let x n -> [n for x next] ;

-- apply a block n times and collect the results
: collect ( xt n -- xs ) let f n -> [n for f apply next] ;

-- generate a list of numbers from [1..n]
: iota ( n -- xs ) let n -> [n for n i - next] ;

-- find the last element of a list
: last ( xs -- x ) uncons swap each drop i next ;

-- true if any item in a list matches a predicate
: any ( xs p -- bool ) let p -> each i p apply if T exit then next F ;

-- true if all items in a list match a predicate
: all ( xs p -- bool ) inverse any not ;

-- return the first element of a list to match a predicate
: find ( xs p -- x T | F ) let p -> each i p apply if i T exit then next F ;

-- return true if any element of a list is x
: elem ( xs x -- bool ) is any ;

-- apply a block for every element in a list
: iter ( xs xt -- j*x ) let f -> each i f apply next ;

-- concatenate two lists
: append ( xs xs -- xs ) {,} foldr ;

-- join a list of lists
: concat ( [xs] -- xs ) [] {append} foldl ; 

-- map a block across a list, collect the results
: map ( xs xt -- xs ) let xs f -> [xs each i f apply next] ;

-- delete elements from a list that do not match a predicate
: filter ( xs p -- xs ) let xs p -> [xs each i p apply if i then next] ;

-- remove elements from a list that match a predicate
: remove-if ( xs p -- xs ) inverse filter ;

-- remove all occurances of an element from a list
: remove ( xs x -- xs ) is remove-if ;

-- count how many times a predicate is matched in a list
: count-if ( xs p -- n ) {if 1+ then} compose 0 swap foldl ;

-- count the number of times an element occurs in a list
: count ( xs x -- n ) is count-if ;

-- find the best fit in a list
: select ( xs f -- x ) push uncons pop foldl ;

-- create a new list with an element inserted between others
: intersperse ( xs x -- xs )
  let xs x -> xs null if [] else drop [xs tl each x i next] xs hd , then ;

-- split a list into two lists using a predicate
: partition ( xs p -- xs ys ) 2dup filter -rot remove-if swap ;

-- split a list in two, pivot on the first predicate match
: take-until ( xs p -- xs ys )
  let xs f -> [xs each i dup f apply if drop exit then next] ;

-- split a list in two, pivot on the first predicate failure
: take-while ( xs p -- xs ys ) inverse take-until ;

-- insert an element ascending into a list
: insert-by ( xs x f -- xs )
  let x f -> 
      let: test ( xs -- xs x bool ) uncons dup x f apply ->
    null if [] else test if push x f recurse pop , else , x , then then 
  ;

: insert ( xs x -- xs ) {<} insert-by ;

-- join two lists together in sorted order
: merge-with ( xs ys cmp -- xs ) ;
